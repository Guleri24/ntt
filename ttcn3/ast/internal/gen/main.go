package main

import (
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"log"
	"os"
)

type Field struct {
	Name string
	Type ast.Expr
}

func (f *Field) IsArray() bool {
	_, ok := f.Type.(*ast.ArrayType)
	return ok
}

func (f *Field) IsPredefined() bool {
	if id, ok := f.Type.(*ast.Ident); ok && id.Obj == nil {
		return true
	}
	return false
}

func (f *Field) IsTokenType() bool {
	id, ok := f.Type.(*ast.Ident)
	if !ok {
		return false
	}
	return id.Name == "Token"
}

func Fields(s *ast.StructType) []Field {
	ident := func(expr ast.Expr) *ast.Ident {
		var id *ast.Ident
		ast.Inspect(expr, func(n ast.Node) bool {
			switch n := n.(type) {
			case *ast.Ident:
				id = n
				return false
			}
			return true
		})
		return id
	}

	var fields []Field
	for _, field := range s.Fields.List {
		if len(field.Names) == 0 {
			if id := ident(field.Type); id != nil {
				field.Names = []*ast.Ident{id}
			}
		}
		for _, fieldName := range field.Names {
			fields = append(fields, Field{
				Name: fieldName.Name,
				Type: field.Type,
			})
		}
	}
	return fields
}

func main() {
	fset := token.NewFileSet()
	src, err := parser.ParseFile(fset, "ast.go", nil, parser.ParseComments)
	if err != nil {
		log.Fatal(err.Error())
	}

	out, err := os.Create("ast_gen.go")
	if err != nil {
		log.Fatal(err.Error())
	}
	defer out.Close()

	fmt.Fprintf(out, "// Code generated by go generate; DO NOT EDIT.\n\n")
	fmt.Fprintf(out, "package ast\n\n")
	fmt.Fprintf(out, "import \"github.com/nokia/ntt/internal/loc\"\n")
	for _, decl := range src.Decls {
		decl, ok := decl.(*ast.GenDecl)
		if !ok {
			continue
		}
		if decl.Tok != token.TYPE {
			continue
		}
		for _, spec := range decl.Specs {
			spec, ok := spec.(*ast.TypeSpec)
			if !ok {
				continue
			}
			st, ok := spec.Type.(*ast.StructType)
			if !ok {
				continue
			}
			name := spec.Name.Name
			fields := Fields(st)
			fmt.Fprintf(out, "func (n *%s) FirstTok() Token {\n", name)
			fmt.Fprintf(out, "\tswitch {\n")
			for _, field := range fields {
				switch {
				case field.IsArray():
					fmt.Fprintf(out, "\tcase len(n.%s) > 0:\n", field.Name)
					fmt.Fprintf(out, "\t\treturn n.%s[0].FirstTok()\n", field.Name)
				case field.IsPredefined():
				default:

					fmt.Fprintf(out, "\tcase n.%s != nil:\n", field.Name)
					fmt.Fprintf(out, "\t\treturn n.%s", field.Name)
					if !field.IsTokenType() {
						fmt.Fprintf(out, ".FirstTok()")
					}
					fmt.Fprintf(out, "\n")

				}
			}
			fmt.Fprintf(out, "\tdefault:\n")
			fmt.Fprintf(out, "\t\treturn nil\n")
			fmt.Fprintf(out, "\t}\n")
			fmt.Fprintf(out, "}\n\n")

			fmt.Fprintf(out, "func (n *%s) LastTok() Token {\n", name)
			fmt.Fprintf(out, "\tswitch {\n")
			for i := len(fields) - 1; i >= 0; i-- {
				field := fields[i]
				switch {
				case field.IsArray():
					fmt.Fprintf(out, "\tcase len(n.%s) > 0:\n", field.Name)
					fmt.Fprintf(out, "\t\treturn n.%s[len(n.%s)-1].LastTok()\n", field.Name, field.Name)
				case field.IsPredefined():
				default:
					fmt.Fprintf(out, "\tcase n.%s != nil:\n", field.Name)
					fmt.Fprintf(out, "\t\treturn n.%s", field.Name)
					if !field.IsTokenType() {
						fmt.Fprintf(out, ".LastTok()")
					}
					fmt.Fprintf(out, "\n")
				}
			}
			fmt.Fprintf(out, "\tdefault:\n")
			fmt.Fprintf(out, "\t\treturn nil\n")
			fmt.Fprintf(out, "\t}\n")
			fmt.Fprintf(out, "}\n\n")

			fmt.Fprintf(out, "func (n *%s) Children() []Node {\n", name)
			fmt.Fprintf(out, "\tret := make([]Node, 0, %d)\n", len(fields))
			for _, field := range fields {
				switch {
				case field.IsArray():
					fmt.Fprintf(out, "\tfor _, c := range n.%s {\n", field.Name)
					fmt.Fprintf(out, "\t\tret = append(ret, c)\n")
					fmt.Fprintf(out, "\t}\n")
				case field.IsPredefined():
				default:
					fmt.Fprintf(out, "\tif n.%s != nil {\n", field.Name)
					fmt.Fprintf(out, "\t\tret = append(ret, n.%s)\n", field.Name)
					fmt.Fprintf(out, "\t}\n")
				}
			}
			fmt.Fprintf(out, "\t\treturn ret\n")
			fmt.Fprintf(out, "}\n\n")

			fmt.Fprintf(out, "func (n *%s) Inspect(f func(Node) bool) {\n", name)
			fmt.Fprintf(out, "\tif !f(n) {\n")
			fmt.Fprintf(out, "\t\treturn\n")
			fmt.Fprintf(out, "\t}\n")
			for _, field := range fields {
				switch {
				case field.IsArray():
					fmt.Fprintf(out, "\tfor _, c := range n.%s {\n", field.Name)
					fmt.Fprintf(out, "\t\tc.Inspect(f)\n")
					fmt.Fprintf(out, "\t}\n")
				case field.IsPredefined():
				default:
					// We skip tokens, because they are not part of the AST yet.
					if field.IsTokenType() {
						continue
					}
					fmt.Fprintf(out, "\tif n.%s != nil {\n", field.Name)
					fmt.Fprintf(out, "\t\tn.%s.Inspect(f)\n", field.Name)
					fmt.Fprintf(out, "\t}\n")
				}
			}
			fmt.Fprintf(out, "\tf(nil)\n")
			fmt.Fprintf(out, "}\n\n")

			fmt.Fprintf(out, "func (n *%s) Pos() loc.Pos {\n", name)
			fmt.Fprintf(out, "\tif tok := n.FirstTok(); tok != nil {\n")
			fmt.Fprintf(out, "\t\treturn tok.Pos()\n")
			fmt.Fprintf(out, "\t}\n")
			fmt.Fprintf(out, "\treturn loc.NoPos\n")
			fmt.Fprintf(out, "}\n\n")

			fmt.Fprintf(out, "func (n *%s) End() loc.Pos {\n", name)
			fmt.Fprintf(out, "\tif tok := n.LastTok(); tok != nil {\n")
			fmt.Fprintf(out, "\t\treturn tok.End()\n")
			fmt.Fprintf(out, "\t}\n")
			fmt.Fprintf(out, "\treturn loc.NoPos\n")
			fmt.Fprintf(out, "}\n\n")
		}
	}
}
